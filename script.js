let quizData = [];
let currentQuestionIndex = 0;
let score = 0;
let userAnswers = []; // Stores user selections for each question
let currentLanguage = 'en';
let isQuizFinished = false;
let isModeSelected = false; // Tracks whether a mode has already been selected

const translations = {
    en: {
        mainTitle: "Art or AI? ‚Äì The EU-AI-Quiz",
        footerDesc: "A project combining European culture and generative AI evaluation.",
        nextBtn: "Next Question",
        backBtn: "‚¨Ö Go Back",
        langBtn: "üá©üá™ Deutsch",
        fsEnter: "‚õ∂ Fullscreen",
        fsExit: "‚úï Exit Fullscreen",
        question: "Which of these images was <strong>generated by AI</strong>?",
        scoreText: "Score",
        of: "of",
        correct: "‚úÖ CORRECT!",
        incorrect: "‚ùå INCORRECT.",
        originalLabel: "Original",
        aiLabel: "AI",
        finishTitle: "Quiz Finished!",
        restart: "Start Over",
        expert: "Over 90% correct ‚Äì You are an AI expert!",
        advanced: "Great job! You have a sharp eye for digital details.",
        study: "Under 70% ‚Äì You should be more careful with digital elements and study AI work more closely.",
        modelLabel: "Model",
        dateLabel: "Created on",
        promptLabel: "Prompt by",
        byLabel: "by",
        pdLabel: "Public Domain",
        aiActLabel: "EU AI Act Art. 50",
        shortVersion: "Short Version (10 Questions)",
        longVersion: "Full Version (${n} Questions)",
        chooseMode: "Choose your quiz length:",
        exitQuiz: "Exit Quiz",
        finishBtn: "Show Results üèÅ"
    },
    de: {
        mainTitle: "Kunst oder KI? ‚Äì Das EU-KI-Quiz",
        footerDesc: "Ein Projekt, das europ√§ische Kultur und generative KI-Evaluation verbindet.",
        nextBtn: "N√§chste Frage",
        backBtn: "‚¨Ö Zur√ºck",
        langBtn: "üá¨üáß English",
        fsEnter: "‚õ∂ Vollbild",
        fsExit: "‚úï Beenden",
        question: "Welches dieser Bilder wurde von <strong>KI generiert</strong>?",
        scoreText: "Punktestand",
        of: "von",
        correct: "‚úÖ RICHTIG!",
        incorrect: "‚ùå FALSCH.",
        originalLabel: "Original",
        aiLabel: "KI",
        finishTitle: "Quiz beendet!",
        restart: "Neustart",
        expert: "√úber 90 % richtig ‚Äì Du bist ein KI-Experte!",
        advanced: "Gute Arbeit! Du hast ein scharfes Auge f√ºr digitale Details.",
        study: "Unter 70 % ‚Äì Du solltest bei digitalen Elementen vorsichtiger sein und dich intensiver mit KI-Werken besch√§ftigen.",
        modelLabel: "Modell",
        dateLabel: "Erstellt am",
        promptLabel: "Prompt von",
        byLabel: "von",
        pdLabel: "Gemeinfrei",
        aiActLabel: "EU-KI-Verordnung (KI-VO) Art. 50",
        shortVersion: "Kurze Version (10 Fragen)",
        longVersion: "Lange Version (Alle ${n} Fragen)",
        chooseMode: "W√§hle die L√§nge des Quiz:",
        exitQuiz: "Quiz beenden",
        finishBtn: "Ergebnis anzeigen üèÅ"
    }
};

function toggleLanguage() {
    currentLanguage = (currentLanguage === 'en') ? 'de' : 'en';
    const t = translations[currentLanguage];
    
    document.getElementById('main-title').innerText = t.mainTitle;
    document.getElementById('footer-desc').innerText = t.footerDesc;
    document.getElementById('language-toggle').innerText = t.langBtn;
    
    const fsBtn = document.getElementById('fullscreen-toggle');
    if(fsBtn) fsBtn.innerText = document.fullscreenElement ? t.fsExit : t.fsEnter;

    if (isQuizFinished) {
        renderFinishScreen();
    } else if (!isModeSelected) {
        // If no mode has been selected yet, show the selection again.
        showModeSelection();
    } else if (currentQuestionIndex < quizData.length) {
        displayQuestion();
        if (!document.getElementById('feedback-area').classList.contains('hidden')) {
            updateFeedbackContent();
        }
    }
}

function toggleFullscreen() {
    const t = translations[currentLanguage];
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
        document.getElementById('fullscreen-toggle').innerText = t.fsExit;
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
            document.getElementById('fullscreen-toggle').innerText = t.fsEnter;
        }
    }
}

async function loadQuizData() {
    try {
        const response = await fetch('data.json');
        quizData = await response.json();
        shuffleArray(quizData);
        document.getElementById('loading-message').style.display = 'none';

        // New: Let the user select the mode first.
        showModeSelection();
    } catch (e) { console.error("Error loading quiz data:", e); }
}

function showModeSelection() {
    const t = translations[currentLanguage];
    const container = document.getElementById('quiz-header-content');
    const pair = document.querySelector('.image-pair');

    // New: Hide progress bar container
    const progressContainer = document.getElementById('progress-container');
    if (progressContainer) {
        progressContainer.style.display = 'none';
    }
    
    // Hide controls during selection
    document.getElementById('back-button').classList.add('hidden');
    document.getElementById('next-button').classList.add('hidden');

    const fullVersionText = t.longVersion.replace('${n}', quizData.length);

    container.innerHTML = `<h2>${t.chooseMode}</h2>`;
    pair.innerHTML = `
        <div class="mode-selection" style="display:flex; gap:20px; flex-direction:column; width:100%; align-items:center;">
            <button class="score-display" onclick="startQuiz(10)" style="position:static; width:300px;">${t.shortVersion}</button>
            
            <button class="score-display" onclick="startQuiz(${quizData.length})" style="position:static; width:300px;">${fullVersionText}</button>
        </div>
    `;
}

function startQuiz(amount) {
    // RESET scores for the new round
    score = 0;
    currentQuestionIndex = 0;
    userAnswers = [];
    isQuizFinished = false;

    // NEW: Reshow progress bar container
    const progressContainer = document.getElementById('progress-container');
    if (progressContainer) {
        progressContainer.style.display = 'block'; // Making the progress bar visible
    }

    // Shorten the array to the selected count
    isModeSelected = true; // Mode has been selected
    quizData = quizData.slice(0, amount); // Limit the questions to the selection
    displayQuestion();
}

function displayQuestion() {
    const q = quizData[currentQuestionIndex];
    const t = translations[currentLanguage];
    const feedbackArea = document.getElementById('feedback-area');

    // Check if the question has already been answered
    const alreadyAnswered = userAnswers[currentQuestionIndex] !== undefined && userAnswers[currentQuestionIndex] !== null;
    feedbackArea.classList.toggle('hidden', !alreadyAnswered);

    // --- NAVIGATION BUTTONS LOGIC ---
const nextBtn = document.getElementById('next-button');
const backBtn = document.getElementById('back-button');

// 1. Check: Is this the last question?
const isLastQuestion = (currentQuestionIndex === quizData.length - 1);

// 2. Set button text (BEFORE visibility logic)
if (isLastQuestion) {
    nextBtn.innerText = t.finishBtn; // Use 'Show result üèÅ'"
    nextBtn.style.backgroundColor = "#28a745"; // Green for completion
} else {
    nextBtn.innerText = t.nextBtn;   // Use 'Next question'
    nextBtn.style.backgroundColor = "#004284"; // Standard blue
}

// 3. Control visibility
// Show Next/Finish button only if the question has been answered
nextBtn.classList.toggle('hidden', !alreadyAnswered);

// Translate Back button and visibility (not on question 1)
backBtn.innerText = t.backBtn;
backBtn.classList.toggle('hidden', currentQuestionIndex === 0);

    // Header Update
    document.getElementById('quiz-header-content').innerHTML = `
        <h2>${q['country_' + currentLanguage]} (${q['category_' + currentLanguage]})</h2>
        <p class="question-text">${t.question}</p>
        
        <button id="exit-quiz-btn" onclick="location.reload()" class="exit-button-style">
            ‚úñ ${t.exitQuiz}
        </button>

        <div class="score-display">
            ${t.scoreText}: ${score} / ${quizData.length}
            (${currentQuestionIndex + 1} ${t.of} ${quizData.length})
        </div>
    `;

    setTimeout(() => {
        const btn = document.getElementById('exit-quiz-btn');
        if (btn) btn.classList.add('visible');
    }, 100);

    // Conditional shuffle: Skip if images exist in memory
    if (!q.shuffledImages) {
        const isA_AI = (q.solution_ai_image === 'left');
        q.shuffledImages = shuffleArray([
            { path: q.image_a_path, isAI: isA_AI }, 
            { path: q.image_b_path, isAI: !isA_AI }
        ]);
    }

    renderImages(q);
    updateProgressBar();

   // Restore state after answering
    if (alreadyAnswered) {
        updateFeedbackContent();
        document.querySelectorAll('.image-wrapper').forEach(el => {
            el.style.cursor = "default"; 
            
            // Find info window in current image
            const overlay = el.querySelector('.image-info-overlay'); 
            
            // And this line toggles its visibility to 'on'
            if (overlay) {
                overlay.classList.remove('hidden-info');
            }
        });
    }
    updateProgressBar(); // "Update progress bar
}

function renderImages(q) {
    const pair = document.querySelector('.image-pair');
    const t = translations[currentLanguage];
    
    // ALWAYS use q.shuffledImages instead of reshuffling here
    pair.innerHTML = q.shuffledImages.map(img => {
        const label = img.isAI ? (currentLanguage === 'de' ? "KI-Bild:" : "AI Image:") : (t.originalLabel + ":");
        const infoText = img.isAI ? q['info_ai_' + currentLanguage] : q['info_original_' + currentLanguage];

        return `
            <div class="image-wrapper" data-is-ai="${img.isAI}">
                <img src="${img.path}">
                <div class="image-info-overlay hidden-info">
                    <strong>${label}</strong><br>
                    <span>${infoText}</span>
                </div>
            </div>
        `;
    }).join('');

    // Only add event listeners if not YET answered
    const alreadyAnswered = userAnswers[currentQuestionIndex] !== undefined && userAnswers[currentQuestionIndex] !== null;
    if (!alreadyAnswered) {
        document.querySelectorAll('.image-wrapper').forEach(el => {
            el.addEventListener('click', handleAnswer);
        });
    }
}

function translateLicense(license, lang) {
    if (!license) return "";
    const t = translations[lang];
    
    // Check 'Public Domain' first
    if (license.toLowerCase() === "public domain") return t.pdLabel;

    // Identify and replace the 'EU AI Act Art. 50' pattern
    let translated = license.replace("EU AI Act Art. 50", t.aiActLabel);
    
    // Conditional replacement for German language strings
    if (lang === 'de') {
        return translated
            .replace("AI", "KI")             // "Replace 'AI' with 'KI'
            .replace("compliant", "konform") // Replace 'compliant' with 'konform'
            .replace("Generated", "generiert"); // Replace 'Generated' with 'generiert'
    }
    
    return translated;
}

function formatAiAttribution(attr, lang) {
    if (!attr) return "";
    
    let dateStr = "";
    if (attr.generation_date) {
        const dateObj = new Date(attr.generation_date);
        dateStr = dateObj.toLocaleString(lang === 'de' ? 'de-DE' : 'en-US', {
            day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
        });
    }

    const originalPrompt = lang === 'de' 
        ? (attr.full_prompt_de || attr.full_prompt_en) 
        : (attr.full_prompt_en || attr.full_prompt_de);
    
    const finalPrompt = originalPrompt || "No prompt available";

    const author = attr.author || "OpenAI"; 
    const model = attr.model || "DALL-E 3 (via ChatGPT)";
    const version = attr.version || "GPT-4o Integration"; 
    const promptAuthor = attr.prompt_author || "Martin Hohlt"; 
    const license = translateLicense(attr.license, lang);

    // Only the heading and the list
    const labelAiSource = lang === 'de' ? 'Bildquelle des KI-Bildes:' : 'Source of the AI Image:';

    return `
    <div class="attribution ai-attribution" style="line-height: 1.6; text-align: left;">
        <strong>${labelAiSource}</strong><br>
        <strong>Original Prompt:</strong> ${finalPrompt}<br>
        <strong>Author:</strong> ${author}<br>
        <strong>Model:</strong> ${model}<br>
        <strong>Version:</strong> ${version}<br>
        <strong>Prompt Author:</strong> ${promptAuthor}<br>
        <strong>${lang === 'de' ? 'Erstellungsdatum' : 'Generation Date'}:</strong> ${dateStr}<br>
        <strong>${lang === 'de' ? 'Lizenz' : 'License'}:</strong> ${license}
    </div>`;
}

function formatOriginalAttribution(attr, lang) {
    if (!attr) return "";
    const url = attr.source_url || "#";
    const label = lang === 'de' ? 'Bildquelle des Originals:' : 'Source of the Original:';

    // Only bold text and link
    return `
    <div class="attribution">
        <strong>${label}</strong> <a href="${url}" target="_blank">${url}</a>
    </div>`;
}

function updateFeedbackContent() {
    const q = quizData[currentQuestionIndex];
    const t = translations[currentLanguage];
    const wasCorrect = userAnswers[currentQuestionIndex];
    
    const originalAttr = formatOriginalAttribution(q.attribution_original, currentLanguage);
    const aiAttr = formatAiAttribution(q.attribution_ai, currentLanguage);

    // **Duplicate info texts were removed here**
    document.getElementById('feedback-area').innerHTML = `
        <div style="text-align: center; margin-bottom: 20px;">
            <p><strong>${wasCorrect ? t.correct : t.incorrect}</strong></p>
        </div>
        <div class="info-section">
            <div class="info-block">
                ${originalAttr}
            </div>
            <div class="info-block">
                ${aiAttr}
            </div>
        </div>
    `;
}

// Helper function to update the score display
function updateScoreDisplay(isCorrect) {
    const t = translations[currentLanguage];
    const scoreContainer = document.querySelector('.score-display');
    
    if (scoreContainer) {
        // **Update text in the button**
        scoreContainer.innerHTML = `
            ${t.scoreText}: ${score} / ${quizData.length}
            (${currentQuestionIndex + 1} ${t.of} ${quizData.length})
        `;

        // Trigger animations
        scoreContainer.classList.remove('score-bounce', 'score-shake');
        void scoreContainer.offsetWidth; 
        scoreContainer.classList.add(isCorrect ? 'score-bounce' : 'score-shake');
    }
}

//  Integrate the call into your handleAnswer function
function handleAnswer(event) {
    // **Lock: Only answer if not already done**
    if (userAnswers[currentQuestionIndex] !== undefined && userAnswers[currentQuestionIndex] !== null) {
        return;
    }

    const isAi = event.currentTarget.getAttribute('data-is-ai') === "true";
    userAnswers[currentQuestionIndex] = isAi;
    
    // **Score logic**
    if (isAi) {
        score++;
    }
    
    // **Update & animate score display IMMEDIATELY**
    updateScoreDisplay(isAi);

    // **Show feedback area**
    const feedbackArea = document.getElementById('feedback-area');
    if (feedbackArea) {
        feedbackArea.classList.remove('hidden');
    }

    // Show info texts BELOW the images (Important!)
    document.querySelectorAll('.image-info-overlay').forEach(el => {
        el.classList.remove('hidden-info');
    });

    // **Disable further clicks on images**
    document.querySelectorAll('.image-wrapper').forEach(el => {
        el.style.cursor = "default";
    });

    // **Update buttons and texts**
    updateFeedbackContent(); // **Write "Correct" or "Incorrect" into the feedback area**
    
    const nextBtn = document.getElementById('next-button');
    if (nextBtn) {
        nextBtn.classList.remove('hidden');
    }
    // **Update the progress bar immediately**
    updateProgressBar();
}
function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function prevQuestion() {
    if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
        updateProgressBar();
        // **The lines for score deduction and userAnswers = null were removed!**
        document.getElementById('feedback-area').innerHTML = "";
        displayQuestion();
    }
}

function nextQuestion() {
    currentQuestionIndex++;
    updateProgressBar();
    if (currentQuestionIndex < quizData.length) {
        document.getElementById('feedback-area').innerHTML = "";
        displayQuestion();
    } else {
        isQuizFinished = true;
        renderFinishScreen();
    }
}

function renderFinishScreen() {
    const t = translations[currentLanguage];
    const percentage = (score / quizData.length) * 100;
    let motivationalMsg = (percentage >= 90) ? t.expert : (percentage >= 70 ? t.advanced : t.study);

    // **We format the percentage to one decimal place**
    const formattedPercentage = percentage.toFixed(1).replace('.', ',');

    document.getElementById('quiz-container').innerHTML = `
        <div class="finish-screen">
            <h2>${t.finishTitle}</h2>
            <p style="font-size: 1.5em; margin: 20px 0;">
            ${t.scoreText}: <strong>${score} / ${quizData.length}</strong>
            (${formattedPercentage} %)
            </p>
            <p class="question-text">${motivationalMsg}</p>
            <button class="score-display" onclick="location.reload()" style="position:static; margin:30px auto;">
                ${t.restart}</button>
        </div>`;
}
function updateProgressBar() {
    const progressBar = document.getElementById('progress-bar');
    // **We only use the index. For Question 1 (Index 0), the progress is 0%.**
    if (progressBar && quizData.length > 0) {
        // **We count how many answers exist in the array and are not 'null/undefined'**
        const answeredQuestions = userAnswers.filter(ans => ans !== undefined && ans !== null).length;
        
        // Formula: (Current index / Total count) * 100**
        // For Question 1 (Index 0), this results in 0%.**
        const progress = (answeredQuestions / quizData.length) * 100;

        progressBar.style.width = progress + "%";
    }
}
// Just a comment.

window.onload = loadQuizData;